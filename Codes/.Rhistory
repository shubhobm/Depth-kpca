pcv(kpc)
#plot the data projection on the components
plot(rotated(kpc),col=as.integer(iris[-test,5]),
xlab="1st Principal Component",ylab="2nd Principal Component")
library(kernlab)
data(iris)
test <- sample(1:150,20)
kpc <- kpca(~.,data=iris[-test,-5],kernel="rbfdot",
kpar=list(sigma=0.2),features=2)
#print the principal component vectors
pcv(kpc)
#plot the data projection on the components
plot(rotated(kpc),col=as.integer(iris[-test,5]),
xlab="1st Principal Component",ylab="2nd Principal Component")
?pcv
?rotated
x = matrix(c(1,2,3,4),2,2)
x
Kern = function(a,b,sigma) exp(-sum((a - b)^2) / sigma)
Kern(x, x[,1], 1)
x - x[,1]
x - x[1,]
# Kdepth program
Kern = function(a,b,sigma) exp(-sum((a - b)^2) / sigma)
kdepth.SP = function(x, xx, sigma){
n = nrow(xx)
K.mat = matrix(0, nrpw=n*(n-1), ncol=n*(n-1))
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
# calculate depth values for rows of x
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(i in 1:nn) xi[i] = Kern(ix, xx[i,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelese(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(i in 1:nrow(K.mat)){
for(j in 1:i){
iK.mat[i,j] = iK.mat[i,j] - xi[i] - xi[j]
iK.mat[j,i] = K.mat[i,j]
}
}
dep.vec[i] = 1 - t(z) %*% iK.mat %*% z / n
}
}
x = matrix(rnorm(1e2), 10,10)
kdepth.SP(x,x,1)
# Kdepth program
Kern = function(a,b,sigma) exp(-sum((a - b)^2) / sigma)
kdepth.SP = function(x, xx, sigma){
n = nrow(xx)
K.mat = matrix(0, nrow=n*(n-1), ncol=n*(n-1))
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
# calculate depth values for rows of x
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(i in 1:nn) xi[i] = Kern(ix, xx[i,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelese(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(i in 1:nrow(K.mat)){
for(j in 1:i){
iK.mat[i,j] = iK.mat[i,j] - xi[i] - xi[j]
iK.mat[j,i] = K.mat[i,j]
}
}
dep.vec[i] = 1 - t(z) %*% iK.mat %*% z / n
}
}
kdepth.SP(x,x,1)
xx = x
n = nrow(xx)
K.mat = matrix(0, nrow=n*(n-1), ncol=n*(n-1))
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
sigma=1
n = nrow(xx)
K.mat = matrix(0, nrow=n*(n-1), ncol=n*(n-1))
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
n = nrow(xx)
K.mat = matrix(0, nrow=n, ncol=n)
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
K.mat
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(i in 1:nn) xi[i] = Kern(ix, xx[i,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelese(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(i in 1:nrow(K.mat)){
for(j in 1:i){
iK.mat[i,j] = iK.mat[i,j] - xi[i] - xi[j]
iK.mat[j,i] = K.mat[i,j]
}
}
dep.vec[i] = 1 - t(z) %*% iK.mat %*% z / n
}
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(i in 1:nn) xi[i] = Kern(ix, xx[i,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(i in 1:nrow(K.mat)){
for(j in 1:i){
iK.mat[i,j] = iK.mat[i,j] - xi[i] - xi[j]
iK.mat[j,i] = K.mat[i,j]
}
}
dep.vec[i] = 1 - t(z) %*% iK.mat %*% z / n
}
dep.vec
z
n = nrow(xx)
K.mat = matrix(0, nrow=n, ncol=n)
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
# calculate depth values for rows of x
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(i in 1:nn) xi[i] = Kern(ix, xx[i,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(i in 1:nrow(K.mat)){
for(j in 1:i){
iK.mat[i,j] = iK.mat[i,j] - xi[i] - xi[j]
iK.mat[j,i] = K.mat[i,j]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
dep.vec
ix
iK.mat
xi
K.mat
plot(K.mt)
plot(K.mat)
summary(K.mat)
i=1
ix = x[i,]
xi = rep(0, nn)
for(i in 1:nn) xi[i] = Kern(ix, xx[i,], sigma)
xi
x
xx
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
del
z = ifelse(del==0, 0, 1/del)
z
x = rnorm(1e3, ncol=10)
x = matrix(rnorm(1e3), ncol=10)
xx = x
n = nrow(xx)
K.mat = matrix(0, nrow=n, ncol=n)
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
# calculate depth values for rows of x
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(i in 1:nn) xi[i] = Kern(ix, xx[i,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(i in 1:nrow(K.mat)){
for(j in 1:i){
iK.mat[i,j] = iK.mat[i,j] - xi[i] - xi[j]
iK.mat[j,i] = K.mat[i,j]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
dep.vec
xx
nn
n = nrow(xx)
K.mat = matrix(0, nrow=n, ncol=n)
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
# calculate depth values for rows of x
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(j in 1:nn) xi[j] = Kern(ix, xx[j,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(j in 1:nrow(K.mat)){
for(k in 1:j){
iK.mat[j,k] = iK.mat[j,k] - xi[j] - xi[k]
iK.mat[k,j] = K.mat[j,k]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
dep.vec
z
xx = rnorm(2e2, ncol=2)
xx = matrix(rnorm(2e2), ncol=2)
x = xx
n = nrow(xx)
K.mat = matrix(0, nrow=n, ncol=n)
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
# calculate depth values for rows of x
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(j in 1:nn) xi[j] = Kern(ix, xx[j,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(j in 1:nrow(K.mat)){
for(k in 1:j){
iK.mat[j,k] = iK.mat[j,k] - xi[j] - xi[k]
iK.mat[k,j] = K.mat[j,k]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
dep.vec
plot(xx)
plot(xx, pch=19)
kdepth.SP = function(x, xx, sigma){
n = nrow(xx)
K.mat = matrix(0, nrow=n, ncol=n)
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
# calculate depth values for rows of x
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(j in 1:nn) xi[j] = Kern(ix, xx[j,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(j in 1:nrow(K.mat)){
for(k in 1:j){
iK.mat[j,k] = iK.mat[j,k] - xi[j] - xi[k]
iK.mat[k,j] = K.mat[j,k]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
}
kdepth.SP = function(x, xx, sigma){
n = nrow(xx)
K.mat = matrix(0, nrow=n, ncol=n)
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
# calculate depth values for rows of x
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(j in 1:nn) xi[j] = Kern(ix, xx[j,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(j in 1:nrow(K.mat)){
for(k in 1:j){
iK.mat[j,k] = iK.mat[j,k] - xi[j] - xi[k]
iK.mat[k,j] = K.mat[j,k]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
dep.vec
}
z = dep.vec(x,x,1)
z = kdepth.SP(x,x,1)
z2 = kdepth.SP(x,x,2)
plot(z,z2, type="l", lwd=2)
plot(z,z2)
hist(z)
hist(z2)
hist(kdepth.SP(x,x,3))
hist(kdepth.SP(x,x,5))
n = nrow(xx)
K.mat = matrix(0, nrow=n, ncol=n)
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
# calculate depth values for rows of x
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(j in 1:nn) xi[j] = Kern(ix, xx[j,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(j in 1:nrow(K.mat)){
for(k in 1:j){
iK.mat[j,k] = iK.mat[j,k] - xi[j] - xi[k]
iK.mat[k,j] = K.mat[j,k]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
dep.vec
plot(dep.vec)
sqrt(t(z) %*% iK.mat %*% z)
sqrt(t(z) %*% iK.mat %*% z)/n
n
hist(kdepth.SP(x,x,.3))
hist(kdepth.SP(x,x,.1))
hist(kdepth.SP(x,x,.01))
hist(kdepth.SP(x,x,.05))
hist(kdepth.SP(x,x,.04))
setwd("C:/Study/My projects/Depth-kpca/Codes")
rm(list=ls())
setwd("C:/Study/My projects/Depth-kpca/Codes")
source("misc_functions.R")
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-2,2), Sigma=sig)
X3 = my.mvrnorm(500, mu=c(2,-2), Sigma=sig)
X = rbind(X1,X3)
mingrid=-5
maxgrid=5
res=.2
pts = seq(mingrid, maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
d = kdepth.SP(xygrid, X, 1)
d = kdepth.SP(X, X, 1)
x = xygrid
xx = X
sigma=1
n = nrow(xx)
K.mat = matrix(0, nrow=n, ncol=n)
## initialize kernel matrix
for(i in 1:nrow(K.mat)){
for(j in 1:i){
K.mat[i,j] = Kern(xx[i,], xx[j,], sigma)
K.mat[j,i] = K.mat[i,j]
}
}
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(j in 1:nn) xi[j] = Kern(ix, xx[j,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(j in 1:nrow(K.mat)){
for(k in 1:j){
iK.mat[j,k] = iK.mat[j,k] - xi[j] - xi[k]
iK.mat[k,j] = K.mat[j,k]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
j
i
nn
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, nn)
for(j in 1:n) xi[j] = Kern(ix, xx[j,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(j in 1:nrow(K.mat)){
for(k in 1:j){
iK.mat[j,k] = iK.mat[j,k] - xi[j] - xi[k]
iK.mat[k,j] = K.mat[j,k]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
z
dim(z)
length(z)
dim(iK.mat)
nn = nrow(x)
dep.vec = rep(0, nn)
for(i in 1:nn){
ix = x[i,]
xi = rep(0, n)
for(j in 1:n) xi[j] = Kern(ix, xx[j,], sigma)
del = sqrt(Kern(ix, ix, sigma) + diag(K.mat) - 2*xi)
z = ifelse(del==0, 0, 1/del)
iK.mat = Kern(ix, ix, sigma) + K.mat
for(j in 1:nrow(K.mat)){
for(k in 1:j){
iK.mat[j,k] = iK.mat[j,k] - xi[j] - xi[k]
iK.mat[k,j] = K.mat[j,k]
}
}
dep.vec[i] = 1 - sqrt(t(z) %*% iK.mat %*% z) / n
}
ls()
rain_1973_2013_test <- read.csv("C:/Study/My projects/Climate-indian monsoon/rain_1973_2013_test.csv")
View(rain_1973_2013_test)
levels(rain_1973_2013_test$STATION_NAME)
names(rain_1973_2013_test)
summary(rain_1973_2013_test$year)
summary(rain_1973_2013_test$PRCP[which(rain_1973_2013_test$year==1994)])
hist(rain_1973_2013_test$PRCP[which(rain_1973_2013_test$year==1994)])
hist(log(rain_1973_2013_test$PRCP[which(rain_1973_2013_test$year==1994)]+1))
attach(rain_1973_2013_test)
p1 = PRCP[PRCP_mm<64.4]
hist(p1)
hist(p2)
p2 = PRCP_mm[(PRCP_mm>=64.4 & PRCP_mm<124.4]
p2 = PRCP_mm[(PRCP_mm>=64.4 & PRCP_mm<124.4)]
summary(p2)
hist(p2)
p3 = PRCP_mm[(PRCP_mm>=124.4)]
hist(p2)
hist(p3)
hist(log(p3)
)
